<style>
  .button.is-tab-button {
    opacity: 60%;
  }
  .button.is-tab-button.is-active {
    opacity: 100%;
  }
</style>
<div class="padding-global padding-section-medium">
  <div class="container-large">
    <div x-data="{tab: {{section.index}}1}" class="category_wrapper">
      <div class="category_top">
        <div role="tablist" li-for:inside="collection in section.settings.collection_list" class="tab_menu">
          {% for collection in section.settings.collection_list %}
            <button
              role="tab"
              x-on:click="tab = {{section.index}}{{forloop.index}}"
              aria-controls="collection-tab-{{section.index}}{{forloop.index}}"
              id="collection-button-{{section.index}}{{forloop.index}}"
              x-bind:aria-selected="tab === {{section.index}}{{forloop.index}} ? 'true' : 'false'"
              x-bind:class="tab === {{section.index}}{{forloop.index}} ? 'is-active' : ''"
              class="button is-tab-button"
            >
              <div li-object="collection.title">{{ collection.title }}</div>
            </button>
          {% endfor %}
        </div>
      </div>
      <div li-for:inside="collection in section.settings.collection_list" class="tab_body">
        {% for collection in section.settings.collection_list %}
          <div
            id="collection-tab-{{section.index}}{{forloop.index}}"
            role="tabpanel"
            aria-labelledby="collection-button-{{section.index}}{{forloop.index}}"
            x-show="tab === {{section.index}}{{forloop.index}}"
            class="category_tab-panel"
          >
            <div class="splide slider">
              <div class="splide__track">
                <div li-for:inside="product in collection.products limit: 4" class="splide__list">
                  {% for product in collection.products limit: 4 %}
                    <div class="splide__slide">{% render 'product_item', product: product %}</div>
                  {% endfor %}
                </div>
              </div>
            </div>
            <a li-object:href="collection.url" href="{{ collection.url }}" class="button is-secondary w-button"
              >En voir plus</a
            >
          </div>
        {% endfor %}
      </div>
    </div>
  </div>
</div>
<div class="hide w-embed"></div>
<div class="hide w-embed w-script">
  <script>
  // Map pour stocker les instances Splide
  const splideInstances = new Map();
  
  // Fonction pour traiter une instance de slider individuelle
  function processSliderInstance(sliderEl) {
    const isMobileOrTablet = window.innerWidth < 992;
    
    // CrÃ©er une clÃ© unique pour ce slider
    if (!sliderEl.dataset.splideId) {
      sliderEl.dataset.splideId = 'splide_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    const sliderId = sliderEl.dataset.splideId;
    const existingInstance = splideInstances.get(sliderId);
    
    console.log(`Processing slider ${sliderId}: mobile=${isMobileOrTablet}, hasInstance=${!!existingInstance}`);
    
    // Si mobile/tablette et pas encore montÃ©
    if (isMobileOrTablet && !existingInstance) {
      try {
        const splide = new Splide(sliderEl, {
          perPage: 4,
          perMove: 1,
          focus: 0,
          type: 'slide',
          gap: '40px',
          arrows: false,
          pagination: true,
          speed: 600,
          dragAngleThreshold: 30,
          autoWidth: false,
          rewind: false,
          rewindSpeed: 400,
          waitForTransition: false,
          updateOnMove: true,
          trimSpace: false,
          breakpoints: {
            991: {
              perPage: 2,
              gap: '32px',
            },
            767: {
              perPage: 1.5,
              gap: '20px',
            },
            479: {
              perPage: 1,
              gap: '16px',
            }
          }
        });
        
        splide.mount();
        splideInstances.set(sliderId, {
          instance: splide,
          element: sliderEl
        });
        
        console.log(`âœ… Splide montÃ© pour ${sliderId}`);
        
        // Refresh au cas oÃ¹ le slider devient visible plus tard
        setTimeout(() => {
          try {
            splide.refresh();
            console.log(`ðŸ”„ Splide refresh pour ${sliderId}`);
          } catch (e) {
            console.log(`Refresh failed for ${sliderId}:`, e);
          }
        }, 100);
        
      } catch (error) {
        console.error(`âŒ Erreur lors du montage de Splide pour ${sliderId}:`, error);
      }
    }
    
    // Si desktop et slider existant â†’ dÃ©truire
    if (!isMobileOrTablet && existingInstance) {
      try {
        existingInstance.instance.destroy();
        splideInstances.delete(sliderId);
        console.log(`ðŸ—‘ï¸ Splide dÃ©truit pour ${sliderId}`);
      } catch (error) {
        console.error(`âŒ Erreur lors de la destruction de Splide pour ${sliderId}:`, error);
      }
    }
  }
  
  // Fonction principale pour traiter tous les sliders
  function initSplideSliders() {
    console.log('ðŸš€ Initialisation des sliders...');
    
    // SÃ©lectionner tous les sliders et les traiter individuellement
    const sliders = document.querySelectorAll('.splide.slider');
    console.log(`Found ${sliders.length} sliders`);
    
    // Traiter chaque slider individuellement
    sliders.forEach((sliderEl, index) => {
      console.log(`Processing slider ${index + 1}/${sliders.length}`);
      processSliderInstance(sliderEl);
    });
    
    // Nettoyer les instances orphelines (sliders qui n'existent plus dans le DOM)
    const currentSliderIds = new Set();
    sliders.forEach(slider => {
      if (slider.dataset.splideId) {
        currentSliderIds.add(slider.dataset.splideId);
      }
    });
    
    splideInstances.forEach((data, sliderId) => {
      if (!currentSliderIds.has(sliderId)) {
        try {
          data.instance.destroy();
          splideInstances.delete(sliderId);
          console.log(`ðŸ§¹ Instance orpheline nettoyÃ©e: ${sliderId}`);
        } catch (error) {
          console.error(`âŒ Erreur lors du nettoyage de l'instance ${sliderId}:`, error);
        }
      }
    });
    
    console.log(`ðŸ“Š Total instances actives: ${splideInstances.size}`);
  }
  
  // Fonction pour rafraÃ®chir tous les sliders actifs (utile quand les tabs changent)
  function refreshAllSliders() {
    console.log('ðŸ”„ Refresh de tous les sliders...');
    splideInstances.forEach((data, sliderId) => {
      try {
        data.instance.refresh();
        console.log(`ðŸ”„ Refreshed ${sliderId}`);
      } catch (error) {
        console.log(`âš ï¸ Refresh failed for ${sliderId}:`, error);
      }
    });
  }
  
  // Fonction de debounce
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  const debouncedInit = debounce(initSplideSliders, 200);
  const debouncedRefresh = debounce(refreshAllSliders, 300);
  
  // Initialisation
  document.addEventListener('DOMContentLoaded', () => {
    console.log('ðŸŽ¯ DOM loaded, initialisation...');
    initSplideSliders();
  });
  
  // GÃ©rer le resize
  window.addEventListener('resize', debouncedInit);
  
  // Observer les clics sur les Ã©lÃ©ments (potentiels changements de tabs)
  document.addEventListener('click', (e) => {
    // Si c'est un bouton de tab ou un Ã©lÃ©ment qui pourrait changer l'affichage
    if (e.target.matches('[id*="button"]') || 
        e.target.closest('[id*="button"]') ||
        e.target.matches('[x-on\\:click]') ||
        e.target.matches('[@click]')) {
      
      console.log('ðŸ–±ï¸ Clic dÃ©tectÃ©, refresh dans 300ms...');
      setTimeout(debouncedRefresh, 300);
    }
  });
  
  // Fonctions utilitaires disponibles globalement
  window.reinitSplideSliders = initSplideSliders;
  window.refreshAllSliders = refreshAllSliders;
  window.debugSplideInstances = () => {
    console.log('ðŸ“‹ Instances Splide actives:');
    splideInstances.forEach((data, sliderId) => {
      console.log(`- ${sliderId}:`, data.element);
    });
  };
  
  console.log('ðŸ“œ Script Splide chargÃ©. Fonctions disponibles: reinitSplideSliders(), refreshAllSliders(), debugSplideInstances()');
  </script>
</div>
{% schema %} {"tag":"section","name":"Collection Tabs","class":"section_category","settings":[{"type":"collection_list","id":"collection_list","label":"Collections","limit":8}],"presets":[{"name":"Collection Tabs","category":"Liquify","blocks":[]}]} {% endschema %}
